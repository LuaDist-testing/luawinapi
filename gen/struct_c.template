//////////////////////////////////////////////////////////////////////////
/**

  luawinapi - winapi wrapper for Lua
  Copyright (C) 2011 Klaus Oberhofer. See copyright notice in
  LICENSE file
  
  !!! This file is generated by gen-w32api.lua  !!!

*/////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>

#ifdef USE_AYGSHELL
#include <aygshell.h>
#endif

#ifdef UNDER_CE
#include <pm.h>
#include <connmgr.h>
#endif

#include <commdlg.h>

#include "gdihelpers.h"

#include "gen_structs.h"
#include "gen_abstractions.h"

// luacwrap c interface
extern luacwrap_cinterface* g_luacwrapiface;

// TODO: type descriptors for OS specific types (like INT_PTR, LRESULT) to enable
// expressions like #winapi.LRESULT


// array type descriptors
//#for name, arr in pairs(arraydefs) do
//#  local basic_type = basic_types[result] or basic_alias
static struct luacwrap_ArrayType regType_$(name) =
{
  LUACWRAP_TC_ARRAY,
  "$(name)",
  $(arr.len),
  sizeof($(arr.alias)),
  "$(arr.typ)"
};

//#end

// member descriptors
//#for _, struct in pairs(structdefs) do

//#     prerequisite_begin(struct, _put)
static luacwrap_RecordMember s_member$(struct.name)[] =
{
//#  for _, member in ipairs(struct.members) do
//#     prerequisite_begin(member, _put)
  { "$(member.name)", offsetof($(struct.name), $(member.name)), "$(get_descriptor_id(member))"},
//#     prerequisite_end(member, _put)
//#  end
  { NULL, 0 }
};

LUACWRAP_DEFINESTRUCT($(libname), $(struct.name));
//#     prerequisite_end(struct, _put)
//#end

int lua_tolwparam( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TLIGHTUSERDATA:
    case LUA_TUSERDATA:
    {
      v = (int)lua_touserdata(L, idx);
    }
    break;
    case LUA_TSTRING:
    {
      v = (int)lua_tostring(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
    case LUA_TNONE:
    case LUA_TNIL:
      // accept none and nil
    break;
    default:
    {
      const char *msg = lua_pushfstring(L, "LPARAM or WPARAM expected but got %s", luaL_typename(L, idx));
      luaL_argerror(L, idx, msg);
    } 
    break;
  }
  return v;
} 

LPCWSTR lua_tostring_or_atom( lua_State *L, int idx )
{
  LPCWSTR v = 0;
  switch (lua_type(L, idx))
  {
    // case LUA_TLIGHTUSERDATA:
    // case LUA_TUSERDATA:
    // {
    //   v = (LPCWSTR)lua_touserdata(L, idx);
    // }
    // break;
    case LUA_TSTRING:
    {
      v = (LPCWSTR)lua_tostring(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = (LPCWSTR)lua_tointeger(L, idx);
    }
    break;
    default:
    {
      const char *msg = lua_pushfstring(L, "LPCWSTR or ATOM expected but got %s", luaL_typename(L, idx));
      luaL_argerror(L, idx, msg);
    } 
    break;
  }
  return v;
} 


int lua_tohandle( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TLIGHTUSERDATA:
    case LUA_TUSERDATA:
    {
      v = (int)lua_touserdata(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
    case LUA_TNONE:
    case LUA_TNIL:
      // accept none and nil
    break;
    default:
    {
      const char *msg = lua_pushfstring(L, "HANDLE (number or userdata) expected but got %s", luaL_typename(L, idx));
      luaL_argerror(L, idx, msg);
    } 
    break;
  }
  return v;
} 

int lua_toresourceref( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TSTRING:
    {
      v = (int)lua_tostring(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
    case LUA_TNONE:
    case LUA_TNIL:
      // accept none and nil
    break;
    default:
    {
      const char *msg = lua_pushfstring(L, "RESOURCEREF (number or string) expected but got %s", luaL_typename(L, idx));
      luaL_argerror(L, idx, msg);
    } 
    break;
  }
  return v;
} 

//////////////////////////////////////////////////////////////////////////
/**

  helper functions to get pointer to DefDlgProc and DefWindowProc

*/////////////////////////////////////////////////////////////////////////

static int winapi_GetDefDlgProcW(lua_State* L)
{
  lua_pushlightuserdata(L,DefDlgProcW);
  return 1;
}

static int winapi_GetDefWindowProcW(lua_State* L)
{
  lua_pushlightuserdata(L,DefWindowProcW);
  return 1;
}

//////////////////////////////////////////////////////////////////////////
/**

  helper functions to process messages (msg loop implementation)

*/////////////////////////////////////////////////////////////////////////

int winapi_ProcessMessages( lua_State *L )
{
  MSG msg;
  while(GetMessage(&msg, NULL, 0, 0))
  {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
  }

  lua_pushnumber(L, msg.wParam);
  return 1;
}

//////////////////////////////////////////////////////////////////////////
/**

  generated wrappers

*/////////////////////////////////////////////////////////////////////////

//#  for _, func in ipairs(funcdefs) do
//#     prerequisite_begin(func, _put)
int winapi_$(func.name)( lua_State *L )
{
  int numret = 0;
//# if (func.rettype ~= "VOID") then
  $(func.rettype) retval;
//# end
//# for i, param in ipairs(func.params) do
  $(declare_param(param, "p" .. i))
//# end

//# for i, param in ipairs(func.params) do
//#   if (param.attribs and param.attribs.ommit) then
  $("p"..i) = $(param.attribs.ommit);
//#   else
  $(marshal_param(param, "in", "p"..i, i))
//#   end
//# end

//# if (func.rettype ~= "VOID") then
  retval = 
//# end
    $(func.name)(
//# for i, param in ipairs(func.params) do
//#   local prefix = ""
//#   if (param.attribs and param.attribs.out) then prefix = "&" end
//#   local postfix = ","
//#   if (i == #func.params) then postfix = "" end
      $(prefix)p$(i)$(postfix)
//# end
    );
//# if (func.rettype ~= "VOID") then

  // marshal retval
  $(marshal_param(func.rettype, "out", "retval", nil))
//# end
//# for _, param in ipairs(func.params) do
//#   if (param.attribs and param.attribs.out) then

  // TODO: marshal $(param.typ)
//# end
//# end

  return numret;
}

//#     prerequisite_end(func, _put)
//#  end

static const luaL_Reg module_lib[ ] = {
  { "GetDefDlgProcW"    , winapi_GetDefDlgProcW  },
  { "GetDefWindowProcW" , winapi_GetDefWindowProcW },
  { "ProcessMessages"   , winapi_ProcessMessages },

//#  for _, func in ipairs(funcdefs) do
//#     prerequisite_begin(func, _put)
  { "$(func.name)",  winapi_$(func.name) },
//#     prerequisite_end(func, _put)
//#  end
  
  { NULL, NULL }
};


//////////////////////////////////////////////////////////////////////////
/**

  registers structures as Lua types

  @param[in]  L  pointer lua state

*/////////////////////////////////////////////////////////////////////////
int register_$(libname)(lua_State *L)
{
  // index of module table
  int M = lua_gettop(L);

  // register package functions
#if (LUA_VERSION_NUM > 501)
  luaL_setfuncs(L, module_lib, 0);
#else
  luaL_openlib(L, NULL, module_lib, 0);
#endif

  // register array types
//#for name, arr in pairs(arraydefs) do
  g_luacwrapiface->registertype(L, M, &regType_$(name).hdr);
//#end
  
  // register structure types
//#for _, struct in pairs(structdefs) do
//#     prerequisite_begin(struct, _put)
  g_luacwrapiface->registertype(L, M, &regType_$(struct.name).hdr);
//#     prerequisite_end(struct, _put)
//#end

  winapi_RegisterWndProc(L);

  registerAbstractions(L);
  
  return 1;
}


