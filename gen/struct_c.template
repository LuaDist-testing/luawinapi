//////////////////////////////////////////////////////////////////////////
/**

  luawinapi - winapi wrapper for Lua
  Copyright (C) 2011 Klaus Oberhofer. See copyright notice in
  LICENSE file
  
  !!! This file is generated by gen-w32api.lua  !!!

*/////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>

#ifdef USE_AYGSHELL
#include <aygshell.h>
#endif

#ifdef UNDER_CE
#include <pm.h>
#include <connmgr.h>
#endif

#include <commdlg.h>

#include "gdihelpers.h"

#include "gen_structs.h"
#include "gen_abstractions.h"

// array type descriptors
//#for name, arr in pairs(arraydefs) do
//#  local basic_type = basic_types[result] or basic_alias
static struct luacwrap_ArrayType regType_$(name) =
{
  LUACWRAP_TC_ARRAY,
  "$(name)",
  $(arr.len),
  sizeof($(arr.alias)),
  "$(arr.typ)"
};

//#end

// member descriptors
//#for _, struct in pairs(structdefs) do

//#     prerequisite_begin(struct, _put)
static luacwrap_RecordMember s_member$(struct.name)[] =
{
//#  for _, member in ipairs(struct.members) do
//#     prerequisite_begin(member, _put)
  { "$(member.name)", offsetof($(struct.name), $(member.name)), "$(get_descriptor_id(member))"},
//#     prerequisite_end(member, _put)
//#  end
  { NULL, 0 }
};

LUACWRAP_DEFINESTRUCT($(libname), $(struct.name));
//#     prerequisite_end(struct, _put)
//#end

int lua_tolwparam( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TLIGHTUSERDATA:
    case LUA_TUSERDATA:
    {
      v = (int)lua_touserdata(L, idx);
    }
    break;
    case LUA_TSTRING:
    {
      v = (int)lua_tostring(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
  }
  return v;
} 

int lua_tohandle( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TLIGHTUSERDATA:
    case LUA_TUSERDATA:
    {
      v = (int)lua_touserdata(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
  }
  return v;
} 

int lua_toresourceref( lua_State *L, int idx )
{
  int v = 0;
  switch (lua_type(L, idx))
  {
    case LUA_TSTRING:
    {
      v = (int)lua_tostring(L, idx);
    }
    break;
    case LUA_TNUMBER:
    {
      v = lua_tointeger(L, idx);
    }
    break;
  }
  return v;
} 

#define LUA_WIN32GUI_LIBNAME "$(libname)"
#define LUA_WIN32GUI_VERSION "$(libname) version $(libversion)"

int luawrap_version( lua_State *L )
{
  lua_pushstring( L, LUA_WIN32GUI_VERSION);
  return 1;
}

int winapi_ProcessMessages( lua_State *L )
{
  MSG msg;
  while(GetMessage(&msg, NULL, 0, 0))
  {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
  }

  lua_pushnumber(L, msg.wParam);
  return 1;
}

//#  for _, func in ipairs(funcdefs) do
//#     prerequisite_begin(func, _put)
int winapi_$(func.name)( lua_State *L )
{
  int numret = 0;
//# if (func.rettype ~= "VOID") then
  $(func.rettype) retval;
//# end
//# for i, param in ipairs(func.params) do
  $(declare_param(param, "p" .. i))
//# end

//# for i, param in ipairs(func.params) do
//#   if (param.attribs and param.attribs.ommit) then
  $("p"..i) = $(param.attribs.ommit);
//#   else
  $(marshal_param(param, "in", "p"..i, i))
//#   end
//# end

//# if (func.rettype ~= "VOID") then
  retval = 
//# end
    $(func.name)(
//# for i, param in ipairs(func.params) do
//#   local prefix = ""
//#   if (param.attribs and param.attribs.out) then prefix = "&" end
//#   local postfix = ","
//#   if (i == #func.params) then postfix = "" end
      $(prefix)p$(i)$(postfix)
//# end
    );
//# if (func.rettype ~= "VOID") then

  // marshal retval  
  $(marshal_param(func.rettype, "out", "retval", nil))
//# end
//# for _, param in ipairs(func.params) do
//#   if (param.out) then

  // marshal $(param.typ)
//# end
//# end

  return numret;
}

//#     prerequisite_end(func, _put)
//#  end

static const luaL_reg module_lib[ ] = {
  { "version"           , luawrap_version },
//  { "unittestPrepare"   , luawrap_unittestPrepare },
//  { "unittestPrintStructA"   , luawrap_unittestPrintStructA },

  { "ProcessMessages"   , winapi_ProcessMessages },

//#  for _, func in ipairs(funcdefs) do
//#     prerequisite_begin(func, _put)
  { "$(func.name)",  winapi_$(func.name) },
//#     prerequisite_end(func, _put)
//#  end
  
  { NULL, NULL }
};

//////////////////////////////////////////////////////////////////////////
/**

  registers structures as Lua types

  @param[in]  L  pointer lua state

*/////////////////////////////////////////////////////////////////////////
int register_$(libname)(lua_State *L)
{
  // index of module table
  int M = lua_gettop(L);

  // register package functions
  luaL_register( L, NULL, module_lib );

  // register array types
//#for name, arr in pairs(arraydefs) do
  luacwrap_registertype(L, M, &regType_$(name).hdr);
//#end
  
  // register structure types
//#for _, struct in pairs(structdefs) do
//#     prerequisite_begin(struct, _put)
  luacwrap_registertype(L, M, &regType_$(struct.name).hdr);
//#     prerequisite_end(struct, _put)
//#end

  winapi_RegisterWndProc(L);

  registerAbstractions(L);
  
  return 1;
}


